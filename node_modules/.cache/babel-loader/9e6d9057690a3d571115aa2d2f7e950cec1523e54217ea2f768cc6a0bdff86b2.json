{"ast":null,"code":"import { formatTimeInput } from './formatters';\nimport { calculateWindModification, needsWindInput } from './windModification';\nimport { coeffs, field_events, thons, COMPETITION_POINTS, SPECIAL_EVENTS, SPECIAL_EVENTS_POINTS } from './coefficients';\nexport const calculatePoints = ({\n  mode,\n  performance,\n  eventType,\n  gender,\n  season,\n  windSpeed\n}) => {\n  try {\n    if (mode === 'points') {\n      const formattedPerformance = formatTimeInput(performance, eventType);\n      if (['800m', '1500m', '3000m', '5000m', '10000m'].includes(eventType) && !formattedPerformance) {\n        console.error('Invalid time format');\n        return null;\n      }\n\n      // Direct calculation instead of API call\n      const a = coeffs[gender][season][eventType].a;\n      const b = coeffs[gender][season][eventType].b;\n      const c = coeffs[gender][season][eventType].c;\n      let basePoints;\n      if (field_events.includes(eventType)) {\n        basePoints = Math.floor(a * Math.pow(formattedPerformance - b, c));\n      } else {\n        basePoints = Math.floor(a * Math.pow(b - formattedPerformance, c));\n      }\n      basePoints = Math.max(0, Math.min(1400, basePoints));\n\n      // Wind adjustment logic remains the same\n      if (season === 'outdoor' && needsWindInput(eventType, season) && windSpeed) {\n        const windAdjustment = calculateWindModification(eventType, parseFloat(windSpeed), basePoints);\n        return {\n          points: basePoints,\n          adjustedPoints: Math.round(basePoints + windAdjustment)\n        };\n      }\n      return {\n        points: basePoints,\n        adjustedPoints: basePoints\n      };\n    }\n    return null;\n  } catch (error) {\n    console.error('Error:', error);\n    return null;\n  }\n};\nexport const calculatePerformance = (event, points, gender = 'mens', season = 'outdoor') => {\n  try {\n    const a = coeffs[gender][season][event].a;\n    const b = coeffs[gender][season][event].b;\n    const c = coeffs[gender][season][event].c;\n    if (points < 0 || points > 1400) {\n      throw new Error(\"Points must be between 0 and 1400\");\n    }\n    if (thons.includes(event)) {\n      return Math.round(b + Math.pow(points / a, 1 / c));\n    } else if (field_events.includes(event)) {\n      return Number((b + Math.pow(points / a, 1 / c)).toFixed(2));\n    } else {\n      return Number((b - Math.pow(points / a, 1 / c)).toFixed(2));\n    }\n  } catch (e) {\n    throw new Error(`Error calculating performance: ${e.message}`);\n  }\n};\nexport const calculatePerformancesBatch = (basePoints, eventType, gender = 'mens', season = 'outdoor') => {\n  try {\n    const results = {};\n    const pointsTable = SPECIAL_EVENTS.includes(eventType) ? SPECIAL_EVENTS_POINTS : COMPETITION_POINTS;\n    for (const meet in pointsTable) {\n      const meetResults = {};\n      for (const [place, bonus] of Object.entries(pointsTable[meet])) {\n        try {\n          const requiredPoints = basePoints - bonus;\n          if (requiredPoints > 1400) {\n            meetResults[place] = 'NaN';\n          } else if (requiredPoints > 0) {\n            const performance = calculatePerformance(eventType, requiredPoints, gender, season);\n            meetResults[place] = performance;\n          } else {\n            meetResults[place] = '-';\n          }\n        } catch {\n          meetResults[place] = '-';\n        }\n      }\n      results[meet] = meetResults;\n    }\n    return results;\n  } catch (e) {\n    console.error(`Error in batch calculation: ${e.message}`);\n    return {};\n  }\n};","map":{"version":3,"names":["formatTimeInput","calculateWindModification","needsWindInput","coeffs","field_events","thons","COMPETITION_POINTS","SPECIAL_EVENTS","SPECIAL_EVENTS_POINTS","calculatePoints","mode","performance","eventType","gender","season","windSpeed","formattedPerformance","includes","console","error","a","b","c","basePoints","Math","floor","pow","max","min","windAdjustment","parseFloat","points","adjustedPoints","round","calculatePerformance","event","Error","Number","toFixed","e","message","calculatePerformancesBatch","results","pointsTable","meet","meetResults","place","bonus","Object","entries","requiredPoints"],"sources":["/Users/simenguttormsen/Documents/WorldAthleticsCalculator/iaaf-frontend/src/utils/calculators.js"],"sourcesContent":["import { formatTimeInput } from './formatters';\nimport { calculateWindModification, needsWindInput } from './windModification';\nimport { coeffs, field_events, thons, COMPETITION_POINTS, SPECIAL_EVENTS, SPECIAL_EVENTS_POINTS } from './coefficients';\n\nexport const calculatePoints = ({\n  mode,\n  performance,\n  eventType,\n  gender,\n  season,\n  windSpeed\n}) => {\n  try {\n    if (mode === 'points') {\n      const formattedPerformance = formatTimeInput(performance, eventType);\n      if (['800m', '1500m', '3000m', '5000m', '10000m'].includes(eventType) && !formattedPerformance) {\n        console.error('Invalid time format');\n        return null;\n      }\n\n      // Direct calculation instead of API call\n      const a = coeffs[gender][season][eventType].a;\n      const b = coeffs[gender][season][eventType].b;\n      const c = coeffs[gender][season][eventType].c;\n      \n      let basePoints;\n      if (field_events.includes(eventType)) {\n        basePoints = Math.floor(a * Math.pow(formattedPerformance - b, c));\n      } else {\n        basePoints = Math.floor(a * Math.pow(b - formattedPerformance, c));\n      }\n      \n      basePoints = Math.max(0, Math.min(1400, basePoints));\n\n      // Wind adjustment logic remains the same\n      if (season === 'outdoor' && needsWindInput(eventType, season) && windSpeed) {\n        const windAdjustment = calculateWindModification(\n          eventType,\n          parseFloat(windSpeed),\n          basePoints\n        );\n        return {\n          points: basePoints,\n          adjustedPoints: Math.round(basePoints + windAdjustment)\n        };\n      }\n      \n      return {\n        points: basePoints,\n        adjustedPoints: basePoints\n      };\n    }\n    return null;\n  } catch (error) {\n    console.error('Error:', error);\n    return null;\n  }\n};\n\nexport const calculatePerformance = (event, points, gender = 'mens', season = 'outdoor') => {\n    try {\n        const a = coeffs[gender][season][event].a;\n        const b = coeffs[gender][season][event].b;\n        const c = coeffs[gender][season][event].c;\n        \n        if (points < 0 || points > 1400) {\n            throw new Error(\"Points must be between 0 and 1400\");\n        }\n        \n        if (thons.includes(event)) {\n            return Math.round(b + Math.pow(points/a, 1/c));\n        } else if (field_events.includes(event)) {\n            return Number((b + Math.pow(points/a, 1/c)).toFixed(2));\n        } else {\n            return Number((b - Math.pow(points/a, 1/c)).toFixed(2));\n        }\n    } catch (e) {\n        throw new Error(`Error calculating performance: ${e.message}`);\n    }\n}; \n\nexport const calculatePerformancesBatch = (basePoints, eventType, gender = 'mens', season = 'outdoor') => {\n    try {\n        const results = {};\n        const pointsTable = SPECIAL_EVENTS.includes(eventType) ? SPECIAL_EVENTS_POINTS : COMPETITION_POINTS;\n        \n        for (const meet in pointsTable) {\n            const meetResults = {};\n            for (const [place, bonus] of Object.entries(pointsTable[meet])) {\n                try {\n                    const requiredPoints = basePoints - bonus;\n                    if (requiredPoints > 1400) {\n                        meetResults[place] = 'NaN';\n                    } else if (requiredPoints > 0) {\n                        const performance = calculatePerformance(eventType, requiredPoints, gender, season);\n                        meetResults[place] = performance;\n                    } else {\n                        meetResults[place] = '-';\n                    }\n                } catch {\n                    meetResults[place] = '-';\n                }\n            }\n            results[meet] = meetResults;\n        }\n        \n        return results;\n    } catch (e) {\n        console.error(`Error in batch calculation: ${e.message}`);\n        return {};\n    }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}